# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'Combiner.ui'
#
# Created by: PyQt5 UI code generator 5.15.2
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui
from PyQt5.QtWidgets import *
from PyQt5.QtGui import *
from PyQt5.QtCore import *
import pandas as pd
import sys
import copy
#from plugin.TestData import TestData
from plugin.CameraData import CameraData
from plugin.DataFigure import DataFigure
from plugin.TestWindow import ErrorInfoList_PyQT5, PdTable, TableWin
import matplotlib.pyplot as plt
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FCanvas
import sip
import os


class DataCombiner_GUI(QMainWindow):
    def __init__(self):
        super(DataCombiner_GUI, self).__init__()
        self.setFixedSize(QSize(1200, 800))
        self.setWindowIcon(QtGui.QIcon('../image/data_analysis.ico'))
        self.setWindowTitle('Camera Test Data Analyst -- By Amazon SQM')
        self.error_file_window = ErrorInfoList_PyQT5()
        self.missing_window = ErrorInfoList_PyQT5()
        self.setupUi()
        self.pareto_figure = DataFigure()
        self.table_view = TableWin()

        self.big_raw_data = CameraData()
        self.medium_raw_data = CameraData()
        self.raw_data = CameraData()


    def setupUi(self):

        # Menu
        self.menubar = QMenuBar(self)
        # self.menubar.setGeometry(QtCore.QRect(0, 0, 800, 23))
        self.menubar.setObjectName("menubar")
        self.menuFile = QMenu('File', self.menubar)
        self.menuFile.setObjectName("menuFile")
        self.menuSearch = QMenu('Search', self.menubar)
        self.menuSearch.setObjectName("menuSearch")
        self.menuData = QMenu('Data', self.menubar)
        self.menuData.setObjectName("menuData")
        self.setMenuBar(self.menubar)

        self.actionOpen_folder = QAction('Open Folder', self)
        self.actionOpen_folder.setShortcut('Ctrl+O')
        self.actionOpen_folder.triggered.connect(self.merge_folder_data)
        self.actionOpen_file = QAction('Open File', self)
        self.actionOpen_file.setShortcut('Ctrl+F')
        self.actionOpen_file.triggered.connect(self.load_file_data)
        self.actionOpen_ref = QAction('Open Reference', self)
        self.actionOpen_ref.setEnabled(False)
        self.actionExport = QAction('Export to csv', self)
        self.actionExport.triggered.connect(self.export_to_table)
        self.actionExit = QAction('Exit', self)
        self.actionExit.triggered.connect(self.close)

        self.actionSearch_ids = QAction('Search Series IDs', self)
        self.actionSearch_ids.triggered.connect(self.search_ids)

        self.actionCalc_retest = QAction('Calculate Retest', self)
        self.actionCalc_retest.triggered.connect(self.calc_retest_data)

        self.menuFile.addAction(self.actionOpen_folder)
        self.menuFile.addAction(self.actionOpen_file)
        self.menuFile.addAction(self.actionOpen_ref)
        self.menuFile.addAction(self.actionExport)
        self.menuFile.addAction(self.actionExit)
        self.menuSearch.addAction(self.actionSearch_ids)
        self.menuData.addAction(self.actionCalc_retest)
        self.menubar.addAction(self.menuFile.menuAction())
        self.menubar.addAction(self.menuSearch.menuAction())
        self.menubar.addAction(self.menuData.menuAction())

        # Toolbar
        self.toolBar = QToolBar()
        self.addToolBar(Qt.TopToolBarArea, self.toolBar)
        self.toolBar.setFixedHeight(80)
        self.toolBar.setIconSize(QSize(40, 40))

        self.tbarOpen_folder = QAction(QIcon('../image/openfolder.svg'), 'Open Folder', self)
        self.tbarOpen_folder.triggered.connect(self.merge_folder_data)
        self.tbarOpen_file = QAction(QIcon('../image/openfile.svg'), 'Open File', self)
        self.tbarOpen_file.triggered.connect(self.load_file_data)
        self.tbarExport = QAction(QIcon('../image/export.svg'), 'Export', self)
        self.tbarExport.triggered.connect(self.export_to_table)
        self.tbarStatistic = QAction(QIcon)
        self.tbarSearch_ids = QAction(QIcon('../image/searchids.svg.'), 'Search Ids', self)
        self.tbarSearch_ids.triggered.connect(self.search_ids)
        self.tbarCalc_retest = QAction(QIcon('../image/recycle.svg'), 'Retest', self)
        self.tbarCalc_retest.triggered.connect(self.calc_retest_data)
        self.tbarExit = QAction(QIcon('../image/exit.svg'), 'Exit', self)
        self.tbarExit.triggered.connect(self.close)

        self.toolBar.addAction(self.tbarOpen_folder)
        self.toolBar.addAction(self.tbarOpen_file)
        self.toolBar.addAction(self.tbarExport)
        self.toolBar.addAction(self.tbarSearch_ids)
        self.toolBar.addAction(self.tbarCalc_retest)
        self.toolBar.addAction(self.tbarExit)

        # Overall
        self.overall_widget = QWidget(self)
        self.overall_widget.setGeometry(QRect(20, 80, 1160, 700))
        self.overall_layout = QGridLayout(self.overall_widget)

        # Left side
        self.left_widget = QWidget(self.overall_widget)
        self.left_layout = QVBoxLayout(self.left_widget)

        self.link_widget = QWidget(self.left_widget)
        self.link_layout = QVBoxLayout()
        self.link_box = QGroupBox('Data Link:', self.link_widget)
        self.link_box.setAlignment(Qt.AlignCenter)
        self.link_box.setFixedWidth(250)
        self.link_ledit = QLineEdit()
        self.link_ledit.setEnabled(False)
        self.refresh_link_btn = QPushButton('Refresh Link', self.link_widget)
        self.refresh_link_btn.clicked.connect(self.refresh_big_data)
        self.link_layout.addWidget(self.link_ledit)
        self.link_layout.addWidget(self.refresh_link_btn)
        self.link_box.setLayout(self.link_layout)

        self.radio_widget = QWidget(self.left_widget)
        self.radio_box = QGroupBox('Data type selection', self.radio_widget)
        self.radio_box.setAlignment(Qt.AlignCenter)
        self.radio_box.setFixedWidth(250)
        self.radio_layout = QVBoxLayout()
        self.radio_layout.setObjectName("radio_layout")
        self.data_type_selection = QButtonGroup()

        self.rawdata_radio = QRadioButton("Raw Data")
        self.rawdata_radio.setObjectName("rawdata_radio")
        self.rawdata_radio.setChecked(True)
        self.fpy_radio = QRadioButton('Final Pass Yield')
        self.fpy_radio.setObjectName("fpy_radio")
        self.firstpy_radio = QRadioButton('First Pass Yield')
        self.firstpy_radio.setObjectName("firstpy_radio")

        self.radio_layout.addWidget(self.rawdata_radio)
        self.radio_layout.addWidget(self.fpy_radio)
        self.radio_layout.addWidget(self.firstpy_radio)
        self.data_type_selection.addButton(self.rawdata_radio, 1)
        self.data_type_selection.addButton(self.fpy_radio, 2)
        self.data_type_selection.addButton(self.firstpy_radio, 3)
        self.data_type_selection.buttonClicked.connect(self.refresh_data)
        self.radio_box.setLayout(self.radio_layout)

        self.yield_widget = QWidget(self.left_widget)
        self.yield_widget.setObjectName("yield_widget")
        self.yield_box = QGroupBox('Overall yield:', self.yield_widget)
        self.yield_box.setFixedWidth(250)
        self.yield_box.setAlignment(Qt.AlignCenter)
        self.yield_layout = QVBoxLayout()

        self.yield_bar = QProgressBar()
        self.yield_bar.setMaximum(100)
        self.yield_bar.setFormat('%p%')
        self.yield_bar.setStyleSheet("QProgressBar{border: 2px solid blue; border-radius: 5px; "
                                     "background-color: #FFFFFF;text-align: center;} "
                                     "QProgressBar::chunk {background-color: #05B8CC; width: 20px;}")

        self.yield_layout.addWidget(self.yield_bar)
        self.yield_box.setLayout(self.yield_layout)

        self.check_widget = QWidget(self.left_widget)
        self.check_box = QGroupBox('Data Filter', self.check_widget)
        self.check_box.setAlignment(Qt.AlignCenter)
        self.check_box.setFixedWidth(250)
        self.check_layout = QVBoxLayout()
        self.repeating_check = QCheckBox('Remove Repeating')
        self.repeating_check.setChecked(True)
        self.id_blank_check = QCheckBox('Remove blank id')
        self.id_blank_check.setChecked(True)
        self.repeating_check.stateChanged.connect(self.refresh_data)
        self.id_blank_check.stateChanged.connect(self.refresh_data)
        self.check_layout.addWidget(self.repeating_check)
        self.check_layout.addWidget(self.id_blank_check)
        self.check_box.setLayout(self.check_layout)

        self.left_layout.addWidget(self.link_box)
        self.left_layout.addWidget(self.radio_box)
        self.left_layout.addWidget(self.check_box)
        self.left_layout.addWidget(self.yield_box)
        self.left_layout.setSpacing(1)

        # Right side
        self.right_widget = QWidget(self)
        self.right_widget.setObjectName("right_widget")
        self.right_layout = QVBoxLayout(self.right_widget)
        self.right_canvas = FCanvas(plt.figure())
        self.right_widget.setContextMenuPolicy(Qt.CustomContextMenu)
        self.right_widget.customContextMenuRequested.connect(self.image_rightmenu)
        self.right_layout.addWidget(self.right_canvas)

        self.overall_layout.addWidget(self.left_widget, 0, 0, 4, 3)
        self.overall_layout.addWidget(self.right_widget, 0, 4, 7, 9)

        self.statusBar().showMessage('Ready')

    def merge_folder_data(self):
        folder_path = QFileDialog.getExistingDirectory(self, 'Open data folder', '', )
        if len(folder_path) > 0:
            self.link_ledit.setText(folder_path)
            self.merge_data(folder_path)
        else:
            QMessageBox.warning(self, "warning", 'No folder defined for loading data')

    def load_file_data(self):
        data_file_path, _ = QFileDialog.getOpenFileName(self, 'Open data file', '', "csv Files (*.csv)")
        if len(data_file_path) > 0:
            self.link_ledit.setText(data_file_path)
            self.merge_data(data_file_path)
        else:
            QMessageBox.warning(self, "warning", 'No file defined for loading data')

    def merge_data(self, data_path):

        self.yield_df = pd.DataFrame()
        self.big_raw_data = CameraData(pathdir=data_path)

        #self.big_raw_data.read_data_from_files(pathdir=data_path)
        self.refresh_big_data()

        QMessageBox.about(self, "Data merage finished",
                          "Total %d files are read and merged, \n %d files cannot be read correctly"
                          % (len(self.big_raw_data.read_files_list), len(self.big_raw_data.wrong_files_list)))
        if len(self.big_raw_data.wrong_files_list) > 0:
            self.error_file_window.setWindowTitle('Read Error Files')
            self.error_file_window.resize(600, 400)
            self.error_file_window.input_text(self.big_raw_data.wrong_files_list)
            self.error_file_window.description_text('The link of the data files which cannot be read correctly:')
            self.error_file_window.exec_()

    def refresh_big_data(self):
        if len(self.big_raw_data) > 0:
            
            self.medium_raw_data = copy.copy(self.big_raw_data)
            self.refresh_data()
            # print('length of big raw data is %d' % len(self.big_raw_data))

    def refresh_data(self):
        if len(self.medium_raw_data) > 0:
            yield_model = self.data_type_selection.checkedId()
            if yield_model == 2:
                self.raw_data.read_from_pd(raw_data=self.medium_raw_data.remove_retest(inplace=False))
            elif yield_model == 1:
                self.raw_data.read_from_pd(raw_data=self.medium_raw_data.value)  # raw data model
            elif yield_model == 3:
                self.raw_data.read_from_pd(raw_data=self.medium_raw_data.remove_retest(inplace=False, how='first'))
            self.raw_data.spec = self.medium_raw_data.spec
            self.raw_data.head_rows = self.medium_raw_data.head_rows
            if self.repeating_check.isChecked():
                self.raw_data.value = self.raw_data.value.dropna(how='all')
            if self.id_blank_check.isChecked():
                self.raw_data.value = self.raw_data.value.dropna(subset = ['serial_id'], how='any')
                #print('length of screened raw data is %d' % len(self.raw_data))
            #print('length of raw data is %d ' % len(self.raw_data))
            self.raw_data.reorganize()
            self.show_yield_pareto()
            self.statusBar().showMessage('Data loaded')

    def show_yield_pareto(self):
        self.yield_df = pd.DataFrame()
        self.yield_df = pd.concat([self.yield_df, self.raw_data.yield_df])

        bar_fig = DataFigure(axsize=[0.1, 0.3, 0.8, 0.6])
        if len(self.raw_data.fail_yield_dict) == 0:
            bar_fig.pareto_bar(input_data={'PASS': 1})
            bar_fig.set_title('All Pass(Total count:' + str(self.raw_data.module_count) + ')')
        else:
            bar_fig.pareto_bar(input_data=self.raw_data.fail_yield_dict)
            bar_fig.set_title('Fail Bin pareto(Total Count: ' + str(self.raw_data.fail_count) +
                              '/' + str(self.raw_data.quantity) + ')')

        self.right_layout.removeWidget(self.right_canvas)
        sip.delete(self.right_canvas)

        self.right_canvas = FCanvas(bar_fig.fig)  # A tk.DrawingArea.
        self.right_layout.addWidget(self.right_canvas)

        self.yield_bar.setValue(int(self.raw_data.yield_value * 100))

    def calc_retest_data(self):
        if len(self.raw_data) > 0:
            yield_model = self.data_type_selection.checkedId()
            if yield_model == 2 or yield_model == 3:
                QMessageBox.warning(self, 'No retest data',
                                    'Retest data are not included, please select "Overall yield model"')
            else:
                self.raw_data.calc_retest()
                retest_times = self.raw_data.retest_sum['Test_times']
                retest_fig = DataFigure(axsize=[0.1, 0.1, 0.8, 0.8], figsize=(6, 5), dpi=60)
                bins = retest_times.max() - 3 + 1
                if bins >= 1:
                    retest_fig.hist_bar(input_data=retest_times, range=(3, retest_times.max()),
                                        bins=retest_times.max() - 3 + 1)
                else:
                    QMessageBox.warning(self, 'warning', 'No >=3 retest times parts could be found!')
                retest_fig.ax.set_xlabel('Test times', fontsize=12)
                retest_fig.ax.set_ylabel('Module count', fontsize=12)
                retest_fig.set_title('Retest Analysis')

                self.right_layout.removeWidget(self.right_canvas)
                sip.delete(self.right_canvas)

                self.right_canvas = FCanvas(retest_fig.fig)
                self.right_layout.addWidget(self.right_canvas)

                self.table_view.resize(600, 400)
                self.table_view.description_text('Summary of retest results')
                self.table_view.show_pd_table(self.raw_data.retest_sum)
                self.table_view.exec_()
                '''retest_sum_model = PdTable(self.raw_data.retest_sum)
                self.table_view.setModel(retest_sum_model)
                self.table_view.show()'''
        else:
            QMessageBox.warning(self, 'No data', 'No real data is loaded!')

    def split_fixture_data(self):
        # print('Split the data according to the fixture')
        self.raw_data.calc_fixture()
        fixture_yield_fig = DataFigure(figsize=(6, 5), dpi=60, axsize=[0.18, 0.05, 0.75, 0.9])
        fixture_id = list(self.raw_data.multi_yield_df.index.tolist())
        yield_fixture_id = list(self.raw_data.multi_yield_df['PASS'])
        yield_fixture_dict = dict(zip(fixture_id, yield_fixture_id))
        fixture_yield_fig.yield_bar(input_data=yield_fixture_dict)

        self.new_chart_layout.removeWidget(self.new_chart_canvas)
        sip.delete(self.new_chart_canvas)
        self.new_chart_canvas = FCanvas(fixture_yield_fig.fig)
        self.new_chart_layout.addWidget(self.new_chart_canvas)

    def search_ids(self):
        search_list_path, _ = QFileDialog.getOpenFileName(self, 'Open id file', '', "All Files (*.*)")
        # print(search_list_path)
        if len(search_list_path) > 0:
            if os.path.splitext(search_list_path)[1] in ['.txt', '.TXT']:
                with open(search_list_path) as search_list:
                    s_id = search_list.read()
                s_id_list = s_id.split('\n')
                if s_id_list[-1] == '':
                    s_id_list.remove('')
                s_id_list = [single_id.replace("'", "") for single_id in s_id_list]
            elif os.path.splitext(search_list_path)[1] in ['.csv', '.CSV', '.XLS', '.xls', '.xlsx', 'XLSX']:
                new_device_list = CameraData(pathdir=search_list_path)
                s_id_list = list(new_device_list.uni_serial)
            QMessageBox.about(self, 'Loaded IDs', 'Total %d seiral IDs are loaded' % len(s_id_list))
            self.medium_raw_data.search_ids(s_id_list)
            self.refresh_data()
            self.show_yield_pareto()
            missing_id_list = list(set(s_id_list) - set(self.raw_data.uni_serial))
            print(missing_id_list)
            if len(missing_id_list) > 0:
                QMessageBox.warning(self, 'Missing parts Id', '%d parts cannot be found' % len(missing_id_list))
                self.missing_window.setWindowTitle('Missing Parts List')
                self.missing_window.description_text('Miss parts list:')
                self.missing_window.input_text(missing_id_list)
                self.missing_window.exec_()

    def export_to_table(self):
        if len(self.raw_data) > 0:
            target_name, _ = QFileDialog.getSaveFileName(self, 'Save to excel file', '', 'csv Files (*.csv)')
            if target_name == '':
                QMessageBox.warning(self, '', 'No export table name defined!')
            else:
                if not (os.path.splitext(target_name)[1] in ['.csv', '.CSV']):
                    csv_target_name = target_name + '.csv'

                else:
                    csv_target_name = target_name
                excel_target_name = os.path.splitext(target_name)[0] + '_yield_summary.xlsx'

                # print(self.raw_data.stat_sum)
                self.raw_data.export_to_excel(csv_target_name, excel_target_name)
                QMessageBox.about(self, 'Finish', 'Finish the data exportation!')
        else:
            QMessageBox.warning(self, 'No data', 'No real data is loaded!')

    def image_rightmenu(self):

        self.right_menu = QMenu(self)

        self.actionA = QAction(QIcon('image/保存.png'), u'保存数据',
                               self)  # self.actionA = self.contextMenu.addAction(QIcon("images/0.png"),u'|  动作A')
        self.actionA.setShortcut('Ctrl+S')  # 设置快捷键
        self.right_menu.addAction(self.actionA)  # 把动作A选项添加到菜单

        self.actionB = QAction(QIcon('image/删除.png'), u'删除数据', self)
        self.right_menu.addAction(self.actionB)

        self.actionA.triggered.connect(self.export_to_table)  # 将动作A触发时连接到槽函数 button
        self.actionB.triggered.connect(self.search_ids)

        self.right_menu.popup(QCursor.pos())  # 声明当鼠标在groupBox控件上右击时，在鼠标位置显示右键菜单   ,exec_,popup两个都可以，


if __name__ == '__main__':
    app = QApplication(sys.argv)

    main = DataCombiner_GUI()
    main.show()
    # main.center()

    sys.exit(app.exec_())
